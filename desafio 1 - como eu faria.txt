Para que o kafka tenha um integração com o spring é necessário que adicionemos a dependência spring-cloud-starter-stream-kafka para o projeto. Com essa dependência instalada devemos adicionar algumas configurações no arquivo applications.properties para que o spring seja capaz de saber o endpoint do servidor do kafka, qual o group-id estaremos utilizando e qual estratégia de recebimento de mensagens estamos utilizando.

Na classe de entrada da aplicação devemos criar um método anotado com @Bean que retorna um JsonMessageConverter para que o Spring seja capaz de desserealizar as mensagens recebidas pelo kafka no formato de strings de JSON.

Agora devemos criar as classes de modelo para armazenar os dados no banco de dados. Para isso criamos a classe Transacao anotada com @Entity que terá os atributos privados id do tipo String e anotado com @Id, valor do tipo BigDecimal e anotado com @Positive, estabelecimento do tipo Estabelecimento e anotado com @ManyToOne  e @NotNull, cartao do tipo Cartao e anotado com @ManyToOne e @NotNull e efetivadaEm do tipo LocalDateTime e anotado com @NotNull. Nas anotações @ManyToOne passamos o parâmetro cascade como MERGE para que salve as entidades que são atributos da classe automáticamente quando salvarmos essa entidade. Nessa classe devemos criar um construtor que recebe todos os atributos obrigatórios, no caso todos, e um construtor padrão vazio anotado com @Deprecated.

As classes Estabelecimento e Cartao que usamos para construir a entidade Transacao devem ser criadas também. A classe Cartão deve ser anotada com @Entity e conter os atributos privados id do tipo String, anotado com @Id e @NotBlank e email do tipo String, anotado com @Email e @NotBlank. Ja a classe Estabelecimento também deverá ser anotada com @Entity mas deve conter os atributos privados id do tipo Long e anotado com @Id e @GeneratedValue, nome do tipo String, anotado com @NotBlank, cidade do tipo String, anotado com @NotBlank e endereco do tipo String e anotado com @NotBlank. Ambas as classes devem ter um construtor padrão vazio anotado com @Deprecated e um construtor que recebe os atributos obrigatórios.

Podemos então criar um repositório do Spring Data JPA para nos ajudar a persistir os dados das transações recebidas. Para isso criamos a interface TransacaoRepository que deve extender de CrudRepository

Feito isso criamos uma classe que ira receber e armazenar os dados recebidos no tópico transacoes vindos do kafka. Nessa classe devemos declarar os atributos privados adequados recebidos pela mensagem do kafka com as devidas anotações de validação e anotar adequadamente os atributos do construtor com a anotação @JsonProperty passando os nomes dos atributos correspondentes do objeto recebido na mensagem que o kafka nos envia. Nessa classe eu criaria um método "converte" que retornaria um objeto do tipo Transacao a partir dos dados recebidos.

Por fim devemos criar uma classe que atuará como Listener das mensagens recebidas pelo kafka. Para isso criamos a classe ListenerTransacao que deve ser anotada com @Component e ter um atributo privado injetado com @Autowired do tipo TransacaoRepository e conter um método anotado com @KafkaListener passando o groupId do nosso consumer group e o tópico que queremos ouvir, o que pode ser feito passando as propriedades contidas no arquivo application.properties para deixar essa configuração mais flexível. No método citado devemos receber um argumento da classe EventoTransacao anotado com @Validated que criamos mais cedo, usamos esse argumento para salvar a transação obtida pela chamada do método converte e cumprir nosso objetivo